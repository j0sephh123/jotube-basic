# Jotube Technical Project Summary

## Database Schema (MySQL + Prisma)

### Core Models

```prisma
model Channel {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @unique @db.VarChar(255)
  ytId      String   @unique @db.VarChar(24)
  src       String   @unique @db.VarChar(255)
  videoCount Int
  fetchStartVideoId String    @db.VarChar(11)
  fetchedUntilEnd   Boolean   @default(false)
  lastSyncedAt      DateTime?
  uploads     UploadsVideo[]
  screenshots Screenshot[]
}

model UploadsVideo {
  id            Int          @id @default(autoincrement())
  ytId          String       @unique @db.VarChar(11)
  title         String
  src           String
  publishedAt   String
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  channelId     Int
  channel       Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  nextPageToken String?
  duration      Int?
  artifact      ArtifactType @default(VIDEO)
  thumbnail  Thumbnail?  @relation
  storyboard Storyboard? @relation
  @@index([channelId, artifact])
}

model Thumbnail {
  id             Int          @id @default(autoincrement())
  uploadsVideoId Int          @unique
  uploadsVideo   UploadsVideo @relation(fields: [uploadsVideoId], references: [id], onDelete: Cascade)
  perRow       Int
  totalSeconds Int @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Storyboard {
  id             Int          @id @default(autoincrement())
  uploadsVideoId Int          @unique
  uploadsVideo   UploadsVideo @relation(fields: [uploadsVideoId], references: [id], onDelete: Cascade)
  fragments Int
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Screenshot {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  second Int
  ytChannelId String
  channel     Channel @relation(fields: [ytChannelId], references: [ytId], onDelete: Cascade)
  ytVideoId String
  isFav Boolean?
  @@index([ytChannelId])
  @@index([ytVideoId], name: "idx_screenshot_ytVideoId")
}

enum ArtifactType {
  VIDEO
  SAVED
  DOWNLOADED
  STORYBOARD
  THUMBNAIL
  SCREENSHOT
}
```

## Download Process

### Python Download Service
- **Framework**: FastAPI with asyncio
- **Video Download**: Uses yt-dlp to download YouTube videos
- **File Organization**: Videos saved to `{base_path}/{channel_id}/{video_id}/`
- **Format Support**: MP4, MKV, WebM with configurable quality
- **Progress Tracking**: Real-time download progress via callbacks
- **Duplicate Prevention**: Checks if video already exists before downloading

### Download Flow
1. Video added to download queue via NestJS API
2. Python service processes queue asynchronously
3. yt-dlp downloads video with specified format
4. File saved to organized directory structure
5. Status updated in queue (pending → downloading → completed/failed)

## Screenshot Generation

### FFmpeg-based Screenshot Capture
- **Tool**: FFmpeg CLI process spawned from NestJS
- **Frequency**: 1 screenshot per second (`fps=1`)
- **Output**: PNG files named `{videoId}-{frameNumber}.png`
- **Location**: `{base_path}/{channel_id}/{video_id}/all_screenshots/`
- **Progress**: Real-time progress via stderr parsing and WebSocket events

### Screenshot Processing Flow
1. Video processor triggers screenshot job
2. FFmpeg extracts frames at 1fps
3. Progress events sent via WebSocket
4. Screenshots saved to organized directory
5. Database records created for each screenshot

## Thumbnail Generation

### Sharp-based Image Processing
- **Library**: Sharp for high-performance image manipulation
- **Grid Layout**: Configurable frames per row (default: 8)
- **Dimensions**: 1900px width, 9:16 aspect ratio per frame
- **Spacing**: 10px between frames
- **Output**: Grid thumbnails with 5 rows of frames

### Thumbnail Generation Process
1. Screenshots loaded and sorted by timestamp
2. Frames resized to fit grid dimensions
3. Composite image created with Sharp
4. Multiple thumbnails generated for long videos
5. Files saved to `{base_path}/{channel_id}/{video_id}/thumbnails/`

## Backend Architecture (NestJS)

### Core Dependencies
- NestJS 10.x, TypeScript 5.1.3
- Prisma 6.12.0 with MySQL
- Bull queues with Redis
- Socket.io for WebSocket communication
- Pino for structured logging

### Job Queue System
- **video**: Video processing pipeline
- **download**: YouTube video downloads  
- **storyboard**: Storyboard generation
- **captureScreenshots**: Screenshot extraction

### File Management
- **Base Path**: Configurable via FilePathService
- **Directory Structure**: `{base}/{channel_id}/{video_id}/{type}/`
- **File Operations**: Directory creation, file existence checks
- **Path Resolution**: Centralized path management

## Frontend Architecture (React)

### Core Dependencies
- React 19, TypeScript 5.5.3
- Vite 6.1.0 with SWC
- Tailwind CSS 4.0.7
- Zustand 5.0.3 for state management
- TanStack React Query 5.83.0
- Socket.io client for real-time updates

### State Management
- **Zustand Store**: Centralized state with slice pattern
- **Feature Slices**: Dashboard, thumbnails, websocket, side panel
- **Scoped Hooks**: Feature-specific state access
- **WebSocket Integration**: Real-time progress updates

### Key Components
- **Dashboard**: Channel/video analytics with filtering
- **Gallery**: Thumbnail grid with lightbox
- **Screenshots**: Screenshot grid by date
- **Channel Management**: CRUD operations
- **Upload Processing**: Video processing status

## Data Flow

### Video Processing Pipeline
1. Video added to queue via API
2. Download service processes video
3. Screenshots extracted with FFmpeg
4. Thumbnails generated with Sharp
5. Database updated with artifacts
6. Frontend receives real-time updates

### Real-time Communication
- **WebSocket Events**: screenshots_start, screenshots_progress, screenshots_finish
- **Progress Tracking**: Current screenshot count, filename
- **Status Updates**: Download, processing, completion states

## File System Structure
```
{base_path}/
├── {channel_id}/
│   ├── {video_id}/
│   │   ├── {video_id}.mp4
│   │   ├── all_screenshots/
│   │   │   ├── {video_id}-1.png
│   │   │   ├── {video_id}-2.png
│   │   │   └── ...
│   │   └── thumbnails/
│   │       ├── 0.png
│   │       ├── 1.png
│   │       └── ...
│   └── ...
└── ...
```

## Key Technical Constraints
- **FFmpeg**: Required for screenshot extraction
- **Sharp**: Required for thumbnail generation
- **yt-dlp**: Required for video downloads
- **Redis**: Required for job queues
- **MySQL**: Required for data persistence
- **File System**: Significant storage requirements for videos/screenshots

## GraphQL Integration

### Server-Side (NestJS)
- **Framework**: @nestjs/graphql with Apollo Driver
- **Auto-schema**: Schema automatically generated from TypeScript decorators
- **Resolvers**: Use @Resolver(), @Query(), @Mutation() decorators
- **Types**: Use @ObjectType(), @InputType(), @Field() decorators
- **Integration**: Resolvers use existing services for business logic

### Client-Side (React + Apollo)
- **Codegen**: GraphQL hooks auto-generated from queries/mutations
- **Workflow**: 
  1. Add GraphQL operations to `client/src/api/graphql/queries/queries.ts`
  2. Run codegen to generate TypeScript hooks
  3. Use auto-generated hooks in components
- **Example**: `CREATE_CHANNEL` mutation generates `useCreateChannelMutation` hook

### Migration Strategy
- **Gradual rollout**: Add resolvers one feature at a time
- **Service reuse**: Resolvers call existing service methods
- **Dual endpoints**: REST and GraphQL can coexist during transition
