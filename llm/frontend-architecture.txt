# Frontend API Architecture

## Core API Fetcher

All API calls are made using the `nestFetcher` utility:

```ts
export default async function nestFetcher<T>({
  method,
  url,
  body,
}: Props): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${url}`, {
    method,
    body: body ? JSON.stringify(body) : undefined,
    headers: {
      "Content-Type": "application/json",
    },
  });
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  let data: T;
  try {
    data = await response.json();
  } catch {
    return {} as T;
  }
  return data;
}
```

## API Call Patterns

### 1. Mutations (POST/PUT/PATCH/DELETE)

Use `useMutation` from `@tanstack/react-query`:

```ts
export const useCreatePlaylist = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreatePlaylistDto) =>
      nestFetcher<Playlist>({
        url: "/playlists",
        method: "POST",
        body: data, // NEVER use JSON.stringify here!
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["playlists"] });
    },
  });
};
```

### 2. Queries (GET)

Use `useQuery` from `@tanstack/react-query`:

```ts
export const useGetPlaylists = () => {
  return useQuery({
    queryKey: ["playlists"],
    queryFn: () =>
      nestFetcher<Playlist[]>({
        url: "/playlists",
        method: "GET",
      }),
  });
};
```

### 3. Complex Queries with Parameters

```ts
export const useGetPlaylist = (id: number) => {
  return useQuery({
    queryKey: ["playlist", id],
    queryFn: () =>
      nestFetcher<Playlist>({
        url: `/playlists/${id}`,
        method: "GET",
      }),
    enabled: !!id, // Only run when id exists
  });
};
```

## Common Mistakes to Avoid

### 1. Double JSON.stringify
❌ WRONG - This causes 400 Bad Request errors:
```ts
body: JSON.stringify(data) // nestFetcher already does this!
```

✅ CORRECT:
```ts
body: data // nestFetcher handles JSON.stringify internally
```

### 2. Missing Query Invalidation
❌ WRONG - Data won't refresh after mutations:
```ts
export const useCreatePlaylist = () => {
  return useMutation({
    mutationFn: (data) => nestFetcher({...}),
    // Missing onSuccess with query invalidation
  });
};
```

✅ CORRECT:
```ts
export const useCreatePlaylist = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data) => nestFetcher({...}),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["playlists"] });
    },
  });
};
```

### 3. Incorrect Error Handling
❌ WRONG - Generic error handling:
```ts
onError: (error) => {
  console.error(error); // Too generic
}
```

✅ CORRECT:
```ts
onError: (error: DefaultError) => {
  onError({ message: error.message }); // Specific error handling
}
```

## Error Handling Patterns

### 1. Component-Level Error Handling
```ts
const { data, isLoading, isError } = useGetPlaylists();

if (isLoading) {
  return <div className="flex justify-center p-8">Loading...</div>;
}

if (isError) {
  return <div className="flex justify-center p-8 text-error">Error loading data</div>;
}
```

### 2. Hook-Level Error Handling
```ts
export function useFetchUploads({ onError, onSuccess }: UseFetchUploadsProps) {
  return useMutation({
    mutationFn: (body) => nestFetcher({...}),
    onSuccess,
    onError: (error: DefaultError) => onError({ message: error.message }),
  });
}
```

### 3. Try-Catch in Async Functions
```ts
const handleFetch = async (body: FetchCarouselDataRequest) => {
  try {
    const data = await mutateAsync(body);
    setSlides(data);
  } catch (error) {
    console.log(error);
  }
};
```

## Query Client Configuration

```ts
export const createQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
      staleTime: 0, // Always consider data stale
      refetchOnWindowFocus: true,
    },
  },
});
```

## Best Practices

1. **Always use TypeScript generics** with nestFetcher for type safety
2. **Never JSON.stringify in hooks** - nestFetcher handles this
3. **Always invalidate queries** after mutations to keep UI in sync
4. **Use enabled option** for conditional queries
5. **Handle loading and error states** in components
6. **Use specific error types** instead of generic error handling
7. **Group related queries** with consistent query keys
8. **Use refetch functions** for manual data refresh when needed

## File Structure

- `client/src/shared/api/nestFetcher.ts` - Core API utility
- `client/src/shared/api/queryClient.ts` - React Query configuration
- `client/src/features/*/hooks/use*.ts` - Feature-specific API hooks
- Each feature should have its own hooks directory with API calls